
## ğŸ“š Algoritmos ordenados de mÃ¡s fÃ¡cil a mÃ¡s difÃ­cil:

---

### ğŸ” **BÃºsqueda (Searching) â€” comienza aquÃ­**

1. **Linear Search** âœ…
2. **Binary Search** âœ…

### ğŸ§¹ **Ordenamiento (Sorting) bÃ¡sico**

3. **Bubble Sort** âœ…
4. **Selection Sort** âœ…
5. **Insertion Sort** âœ…
6. **Shell Sort** â— (ligeramente mÃ¡s avanzado)

### âš™ï¸ **Ordenamiento intermedio a avanzado**

7. **Merge Sort** ğŸ” (Divide & Conquer)
8. **Quicksort** ğŸ” (Divide & Conquer)
9. **Heap Sort** ğŸ› ï¸ (requiere estructura heap)
10. **Counting Sort** ğŸ“Š (requiere comprensiÃ³n de rango de datos)
11. **Radix Sort** ğŸ”¢ (multi-paso)
12. **Bucket Sort** ğŸª£ (usa estructura auxiliar + mezcla de algoritmos)

---

## âœ… RecomendaciÃ³n de prÃ¡ctica:

### ğŸ“˜ Problem #1 â€” Linear Search

**ğŸ§  Title:**
Find the First Occurrence of a Target in an Array

**ğŸ“‹ Description:**
Given an array of integers `nums` and an integer `target`, return the **index** of the first occurrence of `target` in the array.
If `target` is not found, return `-1`.

**ğŸ“¥ Input Example:**

```java
nums = {4, 2, 7, 1, 7, 3}
target = 7
```

**ğŸ“¤ Output Example:**

```java
2
```

**ğŸ’¡ Constraints:**

* You must **not** use any library function like `indexOf`.
* Time complexity should be **O(n)**.
* Solve it using **Linear Search**.

---

Una vez lo resuelvas, te ayudo a revisarlo (legibilidad, eficiencia, complejidad).
